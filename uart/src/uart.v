`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 22.07.2022 11:08:01
// Design Name: 
// Module Name: urat
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
// 
// （1）起始位：起始位必须是持续一个比特时间的逻辑 0 电平，标志传输一个字符的开始，接收方可用起始位使自己的接收时钟与发送方的数据同步。
// （2）数据位：数据位紧跟在起始位之后，是通信中的真正有效信息。
//      数据位的位数可以由通信双方共同约定，一般可以是 5 位、7 位或 8 位，
//      标准的 ASCII 码是0~127（7 位），扩展的 ASCII 码是 0~255（8 位）。
//      传输数据时先传送字符的低位，后传送字符的高位。
// （3）奇偶校验位：奇偶校验位仅占一位，用于进行奇校验或偶校验，奇偶检验位不是必须有的。
//      如果是奇校验，需要保证传输的数据总共有奇数个逻辑高位；
//      如果是偶校验，需要保证传输的数据总共有偶数个逻辑高位。
//      由此可见，奇偶校验位仅是对数据进行简单的置逻辑高位或逻辑低位，不会对数据进行实质的判断，
//      这样做的好处是接收设备能够知道一个位的状态，有可能判断是否有噪声干扰了通信以及传输的数据是否同步。
// （4）停止位：停止位可以是是 1 位、1.5 位或 2 位，可以由软件设定。它一定是逻辑1电平，标志着传输一个字符的结束。
// （5）空闲位：空闲位是指从一个字符的停止位结束到下一个字符的起始位开始，表示线路处于空闲状态，必须由高电平来填充。
// 
//  UART数据发送的具体步骤如下：
// （1）初始化后或者无需发送数据，发送端输出逻辑 1，可以有任意数量的空闲位。
// （2）当需要发送数据时，发送端首先输出逻辑 0，作为起始位。
// （3）接着就可以开始输出数据位了，发送端首先输出数据的最低位D0，然后是D1，最后是数据的最高位。
// （4）如果设有奇偶检验位，发送端输出检验位。
// （5）最后，发送端输出停止位（逻辑 1）。
// （6）如果没有信息需要发送，发送端输出逻辑 1（空闲位），如果有信息需要发送，则 转入步骤（2）。
// 
// 在异步通信中，接收端以接收时钟和波特率因子决定每一位的时间长度。下面以波特率因子等于 16
// （接收时钟每 16 个时钟周期使接收移位寄存器移位一次）为例来说明。
// （1）开始通信，信号线为空闲（逻辑 1），当检测到由 1 到 0 的跳变时，开始对接收时钟计数。 
// （2）当计到 8 个时钟的时候，对输入信号进行检测，若仍然为低电平，则确认这是起始位，而不是干扰信号。
// （3）接收端检测到起始位后，隔 16 个接收时钟对输入信号检测一次，把对应的值作为D0 位数据。
// （4）再隔 16 个接收时钟，对输入信号检测一次，把对应的值作为D1 位数据，直到全部数据位都输入。
// （5）检验奇偶检验位。
// （6）接收到规定的数据位个数和校验位之后，通信接口电路希望收到停止位（逻辑1），若此时未收到逻辑 1，
//      说明出现了错误，在状态寄存器中置“帧错误”标志；
//      若没有错误，对全部数据位进行奇偶校验，无校验错时，把数据位从移位寄存器中取出送至数据输入寄存器，
//      若校验错，在状态寄存器中置“奇偶错”标志。
// （7）本帧信息全部接收完，把线路上出现的高电平作为空闲位。
// （8）当信号再次变为低时，开始进入下一帧的检测。
// 
// 接收器以数据波特率16倍的时钟对所接收的数据进行检测：
// 首先正确地检测到起始位,然后逐位确定各个数据位. 接收器在每个接收时钟的上升沿采样数据线,当发现接收数据线出现低电平时,
// 就认为时起始位的开始,若在连续的8个时钟周期内检测到接收数据线仍保持低电平,则认为它为起始位,而不是干扰信号. 
// 此方法能够排除接收线上的噪声干扰,而且提供相当精确的起始位的中间点,为采样提供准确的时间基准.从该时间基准算起,
// 每16个时钟周期采样一次数据线作为输入数据.
//////////////////////////////////////////////////////////////////////////////////


module uart#(
    parameter CLK_FREQ = 65_000_000,
    parameter BAUT_RATE = 115200
)(
    input               CLK,
    input               RSTn,
    
    input               tx_flag,
    input   [7:0]       tx_data,
    output              tx_done,
    
    output              rx_valid,
    output  [7:0]       rx_data,
    
    input               UART_RXD,
    output              UART_TXD
);
    
    wire                tx_baud_en;
    wire                tx_baud_pulse;
    wire                rx_baud_en;
    wire                rx_baud_pulse;


    transmit #(
        .CLK_FREQ           (CLK_FREQ),
        .BAUT_RATE          (BAUT_RATE)
        )u_tx(
        .clk                (CLK            ),
        .rst_n              (RSTn           ),
        .din                (tx_data        ),
        .txd                (UART_TXD       ),
        .tx_flag            (tx_flag        ),
        .done               (tx_done        )
    );
    
    receive #(
        .CLK_FREQ           (CLK_FREQ),
        .BAUT_RATE          (BAUT_RATE)
        )u_rx(
        .clk                (CLK            ),
        .rst_n              (RSTn           ),
        .rxd                (UART_RXD       ),
        .rx_data            (rx_data        ),
        .valid              (rx_valid       )
    );

endmodule